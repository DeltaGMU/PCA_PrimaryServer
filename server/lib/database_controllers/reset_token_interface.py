import uuid
from datetime import datetime, timedelta
from fastapi import HTTPException, status

from server.lib.utils.email_utils import send_email
from server.lib.utils.employee_utils import create_employee_password_hashes
from server.lib.config_manager import ConfigManager
from server.lib.data_models.reset_token import ResetToken
from server.lib.database_manager import get_db_session
from server.lib.data_models.employee import Employee, PydanticForgotPassword, PydanticResetPassword
from sqlalchemy.orm import Session
from sqlalchemy.exc import IntegrityError
from sqlalchemy import sql


async def generate_code() -> str:
    """
    This utility method is used to generate a unique 8-digit string for reset token generation.

    :return: A unique 8-digit reset token.
    :rtype: str
    """
    return str(uuid.uuid4()).upper()[:8]


async def generate_reset_code(forgot_password: PydanticForgotPassword, session: Session = None) -> str:
    """
    This method is used to generate a unique password reset code for an employee that has forgotten his/her password.
    This temporary reset code is saved to the database and must be used by the employee to reset the account's password.
    Upon successful password reset, the temporary reset code is deleted.
    If a reset code is not used within the expiration time as specified in the server configuration file,
    then a new reset code must be generated by the employee to reset his/her password.
    Please note that the password reset system cannot be utilized for the default administrator account,
    however, it can be used for any other administrator account.
    When a reset code is successfully generated, an email containing the code and instructions on how to reset the account's password
    is sent to the employee's primary email.

    :param forgot_password: The ID of the employee whose password needs to be reset.
    :type forgot_password: PydanticForgotPassword
    :param session: The database session used to generate and temporarily save the reset code for the employee account.
    :type session: Session, optional
    :return: The temporary reset code generated for the employee account.
    :rtype: str
    :raises HTTPException: If any of the provided parameters is invalid or a password reset request was sent for the default administrator account.
    :raises RuntimeError: If a reset code could not be generated for the employee due to a system error.
    """
    if session is None:
        session = next(get_db_session())
    if forgot_password.employee_id is None:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="The reset code cannot be generated if the employee ID is null!")
    employee_id = forgot_password.employee_id.strip().lower()
    employee = session.query(Employee).filter(
        Employee.EmployeeID == employee_id
    ).first()
    if employee is None:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Cannot find an employee with a matching employee ID!")
    if employee.EmployeeID == "admin":
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Cannot send a password reset request for the default administrator account.")
    reset_code = await generate_code()
    if reset_code is None:
        raise RuntimeError(f"Unable to generate a reset code for the following employee: {employee_id}")
    else:
        reset_token = session.query(ResetToken).filter(
            ResetToken.EmployeeID == employee_id
        ).first()
        code_issue = int((datetime.utcnow()).timestamp())
        code_expiration = int((datetime.utcnow() + timedelta(minutes=int(ConfigManager().config()['Security Settings']['reset_code_expiry_minutes']))).timestamp())
        if reset_token:
            reset_token.ResetToken = reset_code
            reset_token.Iss = code_issue
            reset_token.Exp = code_expiration
            reset_token.EntryCreated = sql.func.now()
        else:
            try:
                reset_token = ResetToken(
                    token=reset_code,
                    employee_id=employee_id,
                    iss=code_issue,
                    exp=code_expiration
                )
                session.add(reset_token)
                session.flush()
            except IntegrityError:
                raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Cannot find an employee with a matching employee ID!")
    session.commit()
    # Send notification to the primary email that the account has requested a password reset.
    if employee.EmployeeContactInfo.PrimaryEmail:
        send_email(
            to_user=f'{employee.FirstName} {employee.LastName}',
            to_email=employee.EmployeeContactInfo.PrimaryEmail,
            subj="Account Password Reset Code",
            messages=["Your employee account's password reset code is provided below:",
                      f"<b>Reset Code: {reset_code}</b>",
                      "<b>This reset code is temporary and expires in 24 hours.</b>",
                      "Please enter this unique code in the password reset form accessible from the login page.",
                      f"If you don't remember sending a request to reset your password, or are not aware of an administrator doing so on your behalf, "
                      f"please contact an administrator as soon as possible!"]
        )
    return reset_token


async def reset_account_password(reset_password: PydanticResetPassword, session: Session = None) -> Employee:
    """
    This method is used to reset the password of an employee account, provided a valid reset code and new password.
    A valid reset code can only be generated if a password reset request was initiated by either an administrator
    or an employee that used the forgot-password system on the employee login portal.

    :param reset_password: The new password and valid reset code associated to the employee account.
    :type reset_password: PydanticResetPassword
    :param session: The database session used to reset the employee account's password associated with the reset code.
    :type session: Session, optional
    :return: The employee record that has had its password reset.
    :rtype: Employee
    """
    if session is None:
        session = next(get_db_session())
    if None in (reset_password.reset_code, reset_password.new_password):
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="A reset code and new password must be provided to reset an employee account's password.")

    reset_password.reset_code = reset_password.reset_code.strip()
    reset_password.new_password = reset_password.new_password.strip()
    try:
        matching_employee = session.query(Employee, ResetToken).filter(
            ResetToken.EmployeeID == Employee.EmployeeID,
            ResetToken.ResetToken == reset_password.reset_code
        ).first()
    except IntegrityError:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Cannot find an employee with a matching employee ID!")
    if matching_employee is None:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="The reset code provided is invalid! Please try sending a new reset request.")

    employee = matching_employee[0]
    reset_token = matching_employee[1]

    # Verify the current time against the expiration timestamp of the reset code, and delete the reset code if it's expired.
    # This results in an unsuccessful password reset attempt, and a new reset code must be generated by the account owner.
    cur_time = int(datetime.utcnow().timestamp())
    if reset_token.Exp <= cur_time:
        session.delete(reset_token)
        session.commit()
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="The provided reset code has expired! Please try sending a new reset request.")
    else:
        password_hash = await create_employee_password_hashes(reset_password.new_password)
        if password_hash is None:
            raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="The plain text password provided to is invalid!")
        employee.PasswordHash = password_hash
        session.delete(reset_token)
    session.commit()
    # Send notification to the primary email that the account has had a password update.
    if employee.EmployeeContactInfo.PrimaryEmail:
        send_email(
            to_user=f'{employee.FirstName} {employee.LastName}',
            to_email=employee.EmployeeContactInfo.PrimaryEmail,
            subj="Account Password Has Been Changed",
            messages=["<b>Your employee account's password has been changed!</b>",
                      f"If you don't remember resetting your employee account's password, please contact administration as soon as possible!"]
        )
    return employee
